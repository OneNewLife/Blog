<!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Vue and Hook &bull; Mars Blog </title> <meta name="description" content="继上回 Vue 的初体验之后，这一回上了 Vue 的钩。"> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="https://mars.js.org/vue-and-hook/"> <link rel="alternate" type="application/rss+xml" title="Mars Blog" href="https://mars.js.org/feed.xml" /> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div style="padding: 0 1em;"> <h1 class="title"> <a href="/">Mars Blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="/">Home</a></li> <li><a href="/archive.html">Archive</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Vue and Hook</h1> <span class="post-meta"> <time class="post-date" datetime="2016-04-18">Apr 18, 2016</time> <span class="post-author">by Mars Wong</span> </span> </header> <div class="post-content"> <p>继上回 Vue 的初体验之后，这一回上了 Vue 的钩。</p> <p>这里说的“钩”是指 Vue 的生命周期钩子。Vue 实例在创建的时候会有一系列初始化的步骤——建立数据观察、编译模板、创建必要的数据绑定等等。在实例创建的过程中会触发一些生命周期钩子，让自定义的逻辑可以运行。例如 <code class="highlighter-rouge">created</code> 钩子会在实例创建之后调用：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">vue</span><span class="p">({</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">obj</span><span class="p">:</span> <span class="s1">'Tay'</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">created</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Mars loves '</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// this 指向 vm 实例</span>
  <span class="p">},</span>
<span class="p">})</span>

<span class="c1">// Mars loves Tay</span>
</code></pre></div></div> <p>Vue 还有其它钩子，它们会在实例生命周期的不同阶段调用。Vue 的生命周期如下：</p> <p><img src="https://v1.vuejs.org/images/lifecycle.png" alt="Life Cycle" /></p> <p>Vue 的钩子用法如下：</p> <ul> <li><code class="highlighter-rouge">init</code>：在实例初始化时同步调用。此时 <code class="highlighter-rouge">Observe Data</code>、<code class="highlighter-rouge">Events</code> 和 <code class="highlighter-rouge">Watcher</code> 都没有初始化</li> <li><code class="highlighter-rouge">created</code>：在实例创建之后同步调用。此时实例已经解析完毕，意味着已经建立 <code class="highlighter-rouge">Data Binding</code>、计算属性、方法和 <code class="highlighter-rouge">Watcher</code>。但是还没有开始 DOM 编译，<code class="highlighter-rouge">$el</code> 还不存在</li> <li><code class="highlighter-rouge">beforeCompile</code>：在 DOM 编译开始前调用</li> <li><code class="highlighter-rouge">compiled</code>：在 DOM 编译结束后调用。此时所有的指令已经生效，意味着数据的更新将会触发 DOM 的更新。但是不担保 <code class="highlighter-rouge">$el</code> 已插入 DOM</li> <li><code class="highlighter-rouge">ready</code>：在 DOM 编译结束和 <code class="highlighter-rouge">$el</code> 第一次插入 DOM 之后调用（例如在第一次 <code class="highlighter-rouge">attached</code> 钩子之后调用）。注意必须是由实例方法（例如 <code class="highlighter-rouge">vm.$appendTo()</code>）插入才能触发 <code class="highlighter-rouge">ready</code> 钩子</li> <li><code class="highlighter-rouge">attached</code>：在 <code class="highlighter-rouge">$el</code> 插入 DOM 的时候调用。注意必须是由指令或实例方法插入，直接操作 <code class="highlighter-rouge">$el</code> 不会触发这个钩子</li> <li><code class="highlighter-rouge">detached</code>：在 <code class="highlighter-rouge">$el</code> 从 DOM 中删除的时候调用。注意必须是由指令或实例方法删除，直接操作 <code class="highlighter-rouge">$el</code> 不会触发这个钩子</li> <li><code class="highlighter-rouge">beforeDestroy</code>：在开始销毁实例的时候调用。此时实例仍然有功能</li> <li><code class="highlighter-rouge">destroyed</code>：在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。如果有离开过渡，<code class="highlighter-rouge">destroyed</code> 钩子将在过渡之后调用</li> </ul> <p>在了解 Vue 的钩子之后，是不是觉得 Vue 很强大。那问题来了：钩子从何而来？</p> <p>钩子来源于 windows（在 linux 和 Mac OS 如日中天的年代里，是不是觉得 windows 瞬间逼格十足了）。它是 windows 消息处理机制的一部分，通过安装各种钩子， 应用程序能够设置相应的子例程（子程序）来监视系统里的消息传递以及在这些消息到达目标窗口程序之前处理它们。</p> <p>钩子实际上是一个处理消息的程序段（例如 <code class="highlighter-rouge">Vue.init</code>），通过系统（例如 Chrome）调用，把它挂入系统。每当特定的消息（Data）发出，在没有到达目的窗口（View）前，钩子程序（<code class="highlighter-rouge">vm.init</code>）就先捕获这消息，亦即钩子函数先得到控制权（此时 <code class="highlighter-rouge">BrowserProcess</code> 的 <code class="highlighter-rouge">caller</code> 将唤醒 <code class="highlighter-rouge">vm.init</code> 服务）。这时钩子函数即可以加工处理（改变）该消息（执行 <code class="highlighter-rouge">vm.init</code>），也可以不作处理而继续传递该消息（进入到 Vue 生命周期的下一个阶段），还可以强制结束消息的传递（执行 <code class="highlighter-rouge">Vue.destroyed</code>）。</p> <p>到这里我们对 Vue 生命周期钩子的工作原理已经一清二楚了。最后我们再来了解一下原始的 Hook 原理。</p> <p>每一个 Hook 都有一个与之相关联的指针列表——<code class="highlighter-rouge">HookList</code>，由系统来维护。这个列表的指针指向指定的、应用程序定义的、被 <code class="highlighter-rouge">Hook</code> 子程调用的回调函数，也就是该钩子的各个处理子程。当与指定的 <code class="highlighter-rouge">Hook</code> 类型关联的消息发生时，系统就把这个消息传递到 <code class="highlighter-rouge">Hook</code> 子程。一些 <code class="highlighter-rouge">Hook</code> 子程可以只监视消息，或者修改消息，或者停止消息的前进，避免这些消息传递到下一个 <code class="highlighter-rouge">Hook</code> 子程或者目的窗口。最新安装的钩子放在 <code class="highlighter-rouge">HookList-&gt;head</code>，而最早安装的钩子放在 <code class="highlighter-rouge">HookList-&gt;tail</code>，也就是后加入的先获得控制权。</p> <p>Windows 并不要求钩子子程的卸载顺序一定得和安装顺序相反。每当有一个钩子被卸载，Windows 便释放其占用的内存，并更新整个 <code class="highlighter-rouge">HookList</code>。如果程序安装了钩子，但是在尚未卸载钩子之前就结束了，那么系统会自动为它做卸载钩子的操作。</p> <p>钩子子程是一个应用程序定义的回调函数（Callback Function），不能定义成某个类的成员函数，只能定义为普通的 C 函数。用以监视系统或某一特定类型的事件，这些事件可以是与某一特定线程关联的，也可以是系统中所有线程的事件。</p> <p>钩子让复杂的消息传播成为了可能，它让多方消息传播得以稳定进行，并保证了通信平台的稳定性。Evan You 确实慧中秀外，期待 Vue 的演 进，也期待更多的精品。</p> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Vue and Hook&amp;url=https://mars.js.org/vue-and-hook/&amp;hashtags=web,dev,blog,soudev&amp;via=nandomoreirame" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://mars.js.org/vue-and-hook/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"> <i class="fa fa-facebook-square"></i> </a> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://www.facebook.com/maaarswong" target="_blank"><i class="fa fa-facebook"></i></a></li> <li><a href="https://twitter.com/maaarswong" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small> <a href=https://github.com/marswong target="_blank">Mars Wong</a> &copy; 2015 - 2020 All rights reserved. </small> <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"> <img alt="Creative Commons License" style="border-width: 0;margin: .5em auto;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /> </a> </div> </footer> </main> <script src="/js/typed.min.js"></script> <script> window.onload = function () { new Typed('#motto', { strings: ['起风了，唯有努力生存'], contentType: 'html', typeSpeed: 100, showCursor: false }); } </script> </body> </html></body></html>
